:mod:`AFQ.mask`
===============

.. py:module:: AFQ.mask


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   AFQ.mask.MaskFile
   AFQ.mask.FullMask
   AFQ.mask.RoiMask
   AFQ.mask.B0Mask
   AFQ.mask.LabelledMaskFile
   AFQ.mask.ThresholdedMaskFile
   AFQ.mask.ScalarMask
   AFQ.mask.ThresholdedScalarMask
   AFQ.mask.CombinedMask



Functions
~~~~~~~~~

.. autoapisummary::

   AFQ.mask.check_mask_methods


.. function:: check_mask_methods(mask, mask_name=False)

   Helper function
   Checks if mask is a valid mask.
   If mask_name is not False, will throw an error stating the method
   not found and the mask name.
















   ..
       !! processed by numpydoc !!


.. py:class:: MaskFile(suffix, filters={})

   Bases: :class:`AFQ.mask.StrInstantiatesMixin`

   Define a mask based on a file.
   Does not apply any labels or thresholds;
   Generates mask with floating point data.
   Useful for seed and stop masks, where threshold can be applied
   after interpolation (see example).


   :Parameters:

       **suffix** : str
           suffix to pass to bids_layout.get() to identify the file.

       **filters** : str
           Additional filters to pass to bids_layout.get() to identify
           the file.
           Default: {}











   .. rubric:: Examples

   seed_mask = MaskFile(
       "WM_mask",
       {"scope"="dmriprep"})
   api.AFQ(tracking_params={"seed_mask": seed_mask,
                               "seed_threshold": 0.1})



   ..
       !! processed by numpydoc !!

   .. method:: find_path(self, bids_layout, from_path, subject, session)


   .. method:: get_path_data_affine(self, afq_object, row)


   .. method:: apply_conditions(self, mask_data_orig, mask_file)


   .. method:: get_mask(self, afq_object, row)



.. py:class:: FullMask

   Bases: :class:`AFQ.mask.StrInstantiatesMixin`

   Define a mask which covers a full volume.













   .. rubric:: Examples

   brain_mask = FullMask()



   ..
       !! processed by numpydoc !!

   .. method:: find_path(self, bids_layout, from_path, subject, session)


   .. method:: get_mask(self, afq_object, row)



.. py:class:: RoiMask

   Bases: :class:`AFQ.mask.StrInstantiatesMixin`

   Define a mask which is all ROIs or'd together.













   .. rubric:: Examples

   seed_mask = RoiMask()
   api.AFQ(tracking_params={"seed_mask": seed_mask})



   ..
       !! processed by numpydoc !!

   .. method:: find_path(self, bids_layout, from_path, subject, session)


   .. method:: get_mask(self, afq_object, row)



.. py:class:: B0Mask(median_otsu_kwargs={})

   Bases: :class:`AFQ.mask.StrInstantiatesMixin`

   Define a mask using b0 and dipy's median_otsu.


   :Parameters:

       **median_otsu_kwargs: dict, optional**
           Optional arguments to pass into dipy's median_otsu.
           Default: {}











   .. rubric:: Examples

   brain_mask = B0Mask()
   api.AFQ(brain_mask=brain_mask)



   ..
       !! processed by numpydoc !!

   .. method:: find_path(self, bids_layout, from_path, subject, session)


   .. method:: get_mask(self, afq_object, row)



.. py:class:: LabelledMaskFile(suffix, filters={}, inclusive_labels=None, exclusive_labels=None, combine='or')

   Bases: :class:`AFQ.mask.MaskFile`, :class:`AFQ.mask.CombineMaskMixin`

   Define a mask based on labels in a file.


   :Parameters:

       **suffix** : str
           suffix to pass to bids_layout.get() to identify the file.

       **filters** : str
           Additional filters to pass to bids_layout.get() to identify
           the file.
           Default: {}

       **inclusive_labels** : list of ints, optional
           The labels from the file to include from the boolean mask.
           If None, no inclusive labels are applied.

       **exclusive_labels** : lits of ints, optional
           The labels from the file to exclude from the boolean mask.
           If None, no exclusive labels are applied.
           Default: None.

       **combine** : str, optional
           How to combine the boolean masks generated by inclusive_labels
           and exclusive_labels. If "and", they will be and'd together.
           If "or", they will be or'd.
           Note: in this class, you will most likely want to either set
           inclusive_labels or exclusive_labels, not both,
           so combine will not matter.
           Default: "or"











   .. rubric:: Examples

   brain_mask = LabelledMaskFile(
       "aseg",
       {"scope": "dmriprep"},
       exclusive_labels=[0])
   api.AFQ(brain_mask=brain_mask)



   ..
       !! processed by numpydoc !!

   .. method:: apply_conditions(self, mask_data_orig, mask_file)



.. py:class:: ThresholdedMaskFile(suffix, filters={}, lower_bound=None, upper_bound=None, combine='and')

   Bases: :class:`AFQ.mask.MaskFile`, :class:`AFQ.mask.CombineMaskMixin`

   Define a mask based on thresholding a file.
   Note that this should not be used to directly make a seed mask
   or a stop mask. In those cases, consider thresholding after
   interpolation, as in the example for MaskFile.


   :Parameters:

       **suffix** : str
           suffix to pass to bids_layout.get() to identify the file.

       **filters** : str
           Additional filters to pass to bids_layout.get() to identify
           the file.
           Default: {}

       **lower_bound** : float, optional
           Lower bound to generate boolean mask from data in the file.
           If None, no lower bound is applied.
           Default: None.

       **upper_bound** : float, optional
           Upper bound to generate boolean mask from data in the file.
           If None, no upper bound is applied.
           Default: None.

       **combine** : str, optional
           How to combine the boolean masks generated by lower_bound
           and upper_bound. If "and", they will be and'd together.
           If "or", they will be or'd.
           Default: "and"











   .. rubric:: Examples

   brain_mask = ThresholdedMaskFile(
       "brain_mask",
       {"scope"="dmriprep"},
       lower_bound=0.1)
   api.AFQ(brain_mask=brain_mask)



   ..
       !! processed by numpydoc !!

   .. method:: apply_conditions(self, mask_data_orig, mask_file)



.. py:class:: ScalarMask(scalar)

   Bases: :class:`AFQ.mask.MaskFile`

   Define a mask based on a scalar.
   Does not apply any labels or thresholds;
   Generates mask with floating point data.
   Useful for seed and stop masks, where threshold can be applied
   after interpolation (see example).


   :Parameters:

       **scalar** : str
           Scalar to threshold.
           Can be one of "dti_fa", "dti_md", "dki_fa", "dki_md".











   .. rubric:: Examples

   seed_mask = ScalarMask(
       "dti_fa",
       scope="dmriprep")
   api.AFQ(tracking_params={"seed_mask": seed_mask,
                               "seed_threshold": 0.2})



   ..
       !! processed by numpydoc !!

   .. method:: find_path(self, bids_layout, from_path, subject, session)


   .. method:: get_path_data_affine(self, afq_object, row)



.. py:class:: ThresholdedScalarMask(scalar, lower_bound=None, upper_bound=None, combine='and')

   Bases: :class:`AFQ.mask.ThresholdedMaskFile`, :class:`AFQ.mask.ScalarMask`

   Define a mask based on thresholding a scalar mask.
   Note that this should not be used to directly make a seed mask
   or a stop mask. In those cases, consider thresholding after
   interpolation, as in the example for ScalarMask.


   :Parameters:

       **scalar** : str
           Scalar to threshold.
           Can be one of "dti_fa", "dti_md", "dki_fa", "dki_md".

       **lower_bound** : float, optional
           Lower bound to generate boolean mask from data in the file.
           If None, no lower bound is applied.
           Default: None.

       **upper_bound** : float, optional
           Upper bound to generate boolean mask from data in the file.
           If None, no upper bound is applied.
           Default: None.

       **combine** : str, optional
           How to combine the boolean masks generated by lower_bound
           and upper_bound. If "and", they will be and'd together.
           If "or", they will be or'd.
           Default: "and"











   .. rubric:: Examples

   seed_mask = ThresholdedScalarMask(
       "dti_fa",
       lower_bound=0.2)
   api.AFQ(tracking_params={"seed_mask": seed_mask})



   ..
       !! processed by numpydoc !!


.. py:class:: CombinedMask(mask_list, combine='and')

   Bases: :class:`AFQ.mask.StrInstantiatesMixin`, :class:`AFQ.mask.CombineMaskMixin`

   Define a mask by combining other masks.


   :Parameters:

       **mask_list** : list of Masks with find_path and get_mask functions
           List of masks to combine. All find_path methods will be called
           when this find_path method is called. All get_mask methods will
           be called and combined when this get_mask method is called.

       **combine** : str, optional
           How to combine the boolean masks generated by mask_list.
           If "and", they will be and'd together.
           If "or", they will be or'd.
           Default: "and"











   .. rubric:: Examples

   seed_mask = CombinedMask(
       [ThresholdedScalarMask(
           "dti_fa",
           lower_bound=0.2),
       ThresholdedScalarMask(
           "dti_md",
           upper_bound=0.002)])
   api.AFQ(tracking_params={"seed_mask": seed_mask})



   ..
       !! processed by numpydoc !!

   .. method:: find_path(self, bids_layout, from_path, subject, session)


   .. method:: get_mask(self, afq_object, row)



